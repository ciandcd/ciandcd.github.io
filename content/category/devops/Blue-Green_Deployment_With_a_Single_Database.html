<!DOCTYPE html>
    <html lang="zh-cn">
    <head>
    <meta charset="utf-8"/>
    <title>
    Blue-Green Deployment With a Single Database</title></head><body>From:<a href=http://java.dzone.com/articles/blue-green-deployment-single>http://java.dzone.com/articles/blue-green-deployment-single</a><br><br><div><p class="print-link"></p><p>A blue-green deployment is a way to have incremental updates to your production stack without downtime and without any complexity for properly handling rolling updates (including the rollback functionality)</p><p>I don&#8217;t need to repeat&#160;<a href="http://www.haroldnorton.com/blue-green-deployments-using-a-single-database/">this wonderful explanation</a>&#160;or&#160;<a href="http://martinfowler.com/bliki/BlueGreenDeployment.html">Martin Fowler&#8217;s original piece</a>. But I&#8217;ll extend on them.</p><p>A blue-green deployment is one where there is an &#8220;active&#8221; and a &#8220;spare&#8221; set of servers. The active running the current version, and the spare being ready to run any newly deployed version. The &#8220;active&#8221; and &#8220;spare&#8221; is slightly different than &#8220;blue&#8221; and &#8220;green&#8221;, because one set is always &#8220;blue&#8221; and one is always &#8220;green&#8221;, while the &#8220;active&#8221; and &#8220;spare&#8221; labels change.</p><p>On AWS, for example, you can script the deployment by having two child stacks of your main stacks &#8211; active and spare (indicated by a stack label), each having one (or more) auto-scaling group for your application layer, and a script that does the following (applicable to non-AWS as well):</p><ul><li>push build to an accessible location (e.g. s3)</li><li>set the spare auto-scaling group size to the desired value (the spare stays at 0 when not used)</li><li>make it fetch the pushed build on startup</li><li>wait for it to start</li><li>run sanity tests</li><li>switch DNS to point to an ELB in front of the spare ASG</li><li>switch the labels to make the spare one active and vice versa</li><li>set the previously active ASG size to 0</li></ul><p>The&#160;<a href="http://techblog.bozho.net/state-does-not-belong-in-the-code/">application layer is stateless</a>, so it&#8217;s easy to do hot-replaces like that.</p><p>But (as Fowler indicated) the database is the most tricky component. If you have 2 databases, where the spare one is a slave replica of the active one (and that changes every time you switch), the setup becomes more complicated. And you&#8217;ll still have to do schema changes. So using a single database, if possible, is the easier approach, regardless of whether you have a &#8220;regular&#8221; database or a schemaless one.</p><p>In fact, it boils down to having your application modify the database on startup, in a way that works with both versions. This includes schema changes &#8211; table (or the relevant term in the schemaless db) creation, field addition/removal and inserting new data (e.g. enumerations). And it can go wrong in many ways, depending on the data and datatypes. Some nulls, some datatype change that makes a few values unparseable, etc.</p><p>Of course, it&#8217;s harder to do it with a regular SQL database. As suggested in the post I linked earlier, you can use stored procedures (which I don&#8217;t like), or you can use a&#160;<a href="http://techblog.bozho.net/database-migrations-and-java/">database migration tool</a>. For a schemaless database you must do stuff manually, but but fewer actions are normally needed &#8211; you don&#8217;t have to alter tables or explicitly create new ones, as everything is handled automatically. And the most important thing is to not break the running version.</p><p>But how to make sure everything works?</p><ul><li>test on staging &#8211; preferably with a replica of the production database</li><li>(automatically) run your behaviour/acceptance/sanity test suites against the not-yet-active new deployment before switching the DNS to point to it. Stop the process if they fail.</li></ul><p>Only after these checks pass, switch the DNS and point your domain to the previously spare group, thus promoting it to &#8220;active&#8221;. Switching can be done manually, or automatically with the deployment script. The &#8220;switch&#8221; can be other than a DNS one (as you need a low TTL for that). It can be a load-balancer or a subnet configuration, for example &#8211; the best option depends on your setup. And while it is good to automate everything, having a few manual steps isn&#8217;t necessarily a bad thing.</p><p>Overall, I&#8217;d recommend the blue-green deployment approach in order to achieve zero downtime upgrades. But always make sure your database is properly upgraded, so that it works with both the old and the new version.</p>	
	<p></p>

    </div></body></html>